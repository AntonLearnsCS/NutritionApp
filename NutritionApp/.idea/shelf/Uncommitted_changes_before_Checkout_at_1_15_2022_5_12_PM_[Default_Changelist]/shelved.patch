Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*plugins {\r\n    id(\"com.google.secrets_gradle_plugin\") version \"0.6.1\"\r\n  *//*  id('com.android.application')\r\n    id('kotlin-android')\r\n    id('kotlin-kapt')\r\n    id(\"androidx.navigation.safeargs.kotlin\")\r\n    id('com.google.gms.google-services')*//*\r\n}*/\r\n\r\napply plugin: 'com.android.application'\r\napply plugin: 'kotlin-android'\r\napply plugin: 'kotlin-kapt'\r\napply plugin: \"androidx.navigation.safeargs.kotlin\"\r\napply plugin: 'com.google.gms.google-services'\r\nandroid {\r\n    compileSdkVersion 31\r\n    buildToolsVersion \"31.0.0\"\r\n\r\n    defaultConfig {\r\n        applicationId \"com.example.nutritionapp\"\r\n        minSdkVersion rootProject.minSdkVersion\r\n        targetSdkVersion rootProject.targetSdkVersion\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n        multiDexEnabled true\r\n    }\r\n\r\n    configurations.all {\r\n        resolutionStrategy {\r\n            //force \"androidx.lifecycle:lifecycle-runtime-ktx:2.2.0\"\r\n        }\r\n    }\r\n    // exclude group: \"org.jetbrains.kotlinx\", module: \"kotlinx-coroutines-debug\"\r\n\r\n    buildTypes {\r\n        debug {\r\n            buildConfigField 'String', \"MAPS_API_KEY\", MAPS_API_KEY\r\n            resValue 'string', \"MAPS_API_KEY\", MAPS_API_KEY\r\n        }\r\n        release {\r\n            buildConfigField 'String', \"MAPS_API_KEY\", MAPS_API_KEY\r\n            resValue 'string', \"MAPS_API_KEY\", MAPS_API_KEY\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n    lintOptions {\r\n        disable 'NullSafeMutableLiveData'\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n    testOptions.unitTests {\r\n        includeAndroidResources = true\r\n        returnDefaultValues = true\r\n    }\r\n\r\n    compileOptions {\r\n        sourceCompatibility 1.8\r\n        targetCompatibility 1.8\r\n    }\r\n    kotlinOptions {\r\n        jvmTarget = JavaVersion.VERSION_1_8.toString()\r\n    }\r\n    buildFeatures {\r\n        dataBinding true\r\n    }\r\n    packagingOptions{\r\n        exclude 'META-INF/AL2.0'\r\n        exclude 'META-INF/LGPL2.1'\r\n    }\r\n    /*   buildTypes.each {\r\n           it.buildConfigField \"String\", \"Maps_API_KEY\", \"MAPS_API_KEY\"\r\n       }*/\r\n}\r\n\r\ndependencies {\r\n    //include all JARs in the local repository.\r\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\r\n//    implementation files(sdkDir+'/platforms/android-29/android.jar')\r\n    implementation 'com.android.support:multidex:1.0.3'\r\n\r\n    // App dependencies\r\n    implementation \"androidx.appcompat:appcompat:$appCompatVersion\"\r\n    implementation \"androidx.legacy:legacy-support-v4:$androidXLegacySupport\"\r\n    implementation \"androidx.annotation:annotation:$androidXAnnotations\"\r\n\r\n    implementation \"androidx.cardview:cardview:$cardVersion\"\r\n    implementation \"com.google.android.material:material:$materialVersion\"\r\n    implementation \"androidx.recyclerview:recyclerview:$recyclerViewVersion\"\r\n    implementation \"androidx.constraintlayout:constraintlayout:$constraintVersion\"\r\n\r\n    implementation 'com.google.code.gson:gson:2.8.5'\r\n\r\n    // Architecture Components\r\n    //Navigation dependencies\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.0-rc1'\r\n    kapt \"androidx.lifecycle:lifecycle-compiler:$archLifecycleVersion\"\r\n    implementation \"androidx.lifecycle:lifecycle-extensions:2.2.0\"\r\n    //implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$archLifecycleVersion\"\r\n    implementation \"androidx.lifecycle:lifecycle-livedata-ktx:$archLifecycleVersion\"\r\n    implementation \"androidx.navigation:navigation-fragment-ktx:$navigationVersion\"\r\n    implementation \"androidx.navigation:navigation-ui-ktx:$navigationVersion\"\r\n    implementation \"androidx.test.espresso:espresso-idling-resource:$espressoVersion\"\r\n\r\n    //Room dependencies\r\n    implementation \"androidx.room:room-ktx:$roomVersion\"\r\n    implementation \"androidx.room:room-runtime:$roomVersion\"\r\n    kapt \"androidx.room:room-compiler:$roomVersion\"\r\n\r\n    //Coroutines Dependencies\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutinesVersion\"\r\n    implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutinesVersion\"\r\n    //Koin\r\n    implementation \"org.koin:koin-android:$koinVersion\"\r\n    implementation \"org.koin:koin-androidx-viewmodel:$koinVersion\"\r\n\r\n// Koin testing tools\r\n    testImplementation \"io.insert-koin:koin-test:$koinVersion\"\r\n    // Needed JUnit version\r\n    //testImplementation \"io.insert-koin:koin-test-junit4:2.0.1\"\r\n    testImplementation 'org.koin:koin-test:2.0.1'\r\n    // Dependencies for local unit tests\r\n    testImplementation \"junit:junit:$junitVersion\"\r\n    testImplementation \"org.hamcrest:hamcrest-all:$hamcrestVersion\"\r\n    testImplementation \"androidx.arch.core:core-testing:$archTestingVersion\"\r\n    testImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutinesVersion\"\r\n    testImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutinesVersion\"\r\n    testImplementation \"org.robolectric:robolectric:$robolectricVersion\"\r\n    testImplementation \"com.google.truth:truth:$truthVersion\"\r\n    testImplementation \"org.mockito:mockito-core:$mockitoVersion\"\r\n\r\n    // AndroidX Test - JVM testing\r\n    testImplementation \"androidx.test:core-ktx:$androidXTestCoreVersion\"\r\n    testImplementation \"androidx.test.ext:junit-ktx:$androidXTestExtKotlinRunnerVersion\"\r\n    testImplementation \"androidx.test:rules:$androidXTestRulesVersion\"\r\n\r\n    // AndroidX Test - Instrumented testing\r\n    androidTestImplementation \"androidx.test:core-ktx:$androidXTestCoreVersion\"\r\n    androidTestImplementation \"androidx.test.ext:junit-ktx:$androidXTestExtKotlinRunnerVersion\"\r\n    androidTestImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutinesVersion\"\r\n    androidTestImplementation \"androidx.test:rules:$androidXTestRulesVersion\"\r\n    androidTestImplementation \"androidx.room:room-testing:$roomVersion\"\r\n    androidTestImplementation \"androidx.arch.core:core-testing:$archTestingVersion\"\r\n    androidTestImplementation \"org.robolectric:annotations:$robolectricVersion\"\r\n    androidTestImplementation \"androidx.test.espresso:espresso-core:$espressoVersion\"\r\n    androidTestImplementation \"androidx.test.espresso:espresso-contrib:$espressoVersion\"\r\n    androidTestImplementation \"androidx.test.espresso:espresso-intents:$espressoVersion\"\r\n    androidTestImplementation \"androidx.test.espresso.idling:idling-concurrent:$espressoVersion\"\r\n    //For Espresso-intent\r\n    androidTestImplementation('androidx.test:runner:1.4.0')\r\n    androidTestImplementation('androidx.test:rules:1.4.0')\r\n    androidTestImplementation('androidx.test.espresso:espresso-core:3.4.0')\r\n    androidTestImplementation \"junit:junit:$junitVersion\"\r\n\r\n\r\n    // Once https://issuetracker.google.com/127986458 is fixed this can be testImplementation\r\n    implementation \"androidx.fragment:fragment-testing:$fragmentVersion\"\r\n    implementation \"androidx.activity:activity:1.2.0\"\r\n    implementation \"androidx.fragment:fragment:1.3.6\"\r\n\r\n    implementation \"androidx.test:core:$androidXTestCoreVersion\"\r\n    implementation \"androidx.fragment:fragment:$fragmentVersion\"\r\n    androidTestImplementation \"org.mockito:mockito-core:$mockitoVersion\"\r\n    androidTestImplementation \"com.linkedin.dexmaker:dexmaker-mockito:$dexMakerVersion\"\r\n    androidTestImplementation('org.koin:koin-test:2.0.1') { exclude group: 'org.mockito' }\r\n\r\n\r\n\r\n    //Maps & Geofencing\r\n    implementation \"com.google.android.gms:play-services-location:$playServicesVersion\"\r\n    implementation \"com.google.android.gms:play-services-maps:$playServicesVersion\"\r\n\r\n    //firebase\r\n    implementation 'com.firebaseui:firebase-ui-auth:5.0.0'\r\n\r\n    //Timber\r\n    implementation 'com.jakewharton.timber:timber:5.0.1'\r\n    androidTestImplementation \"com.jakewharton.timber:timber:5.0.1\"\r\n\r\n    //geocoder\r\n    implementation 'com.google.android.libraries.places:places:2.4.0'\r\n    testImplementation 'com.google.android.libraries.places:places:2.4.0'\r\n\r\n    // For developers using AndroidX in their applications\r\n    implementation 'pub.devrel:easypermissions:3.0.0'\r\n    implementation \"androidx.core:core-ktx:1.6.0\"\r\n    implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0\"\r\n    implementation \"androidx.lifecycle:lifecycle-runtime-ktx:2.4.0\"\r\n\r\n\r\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\r\n\r\n    //firebase\r\n    //implementation platform('com.google.firebase:firebase-bom:28.4.1')\r\n    //implementation 'com.google.firebase:firebase-analytics-ktx'\r\n\r\n    // Retrofit Coroutines Support\r\n    implementation \"com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:$version_retrofit_coroutines_adapter\"\r\n\r\n    // Retrofit with Moshi Converter\r\n    implementation \"com.squareup.retrofit2:converter-moshi:$version_retrofit\"\r\n    // Moshi\r\n    implementation \"com.squareup.moshi:moshi:$version_moshi\"\r\n    implementation \"com.squareup.moshi:moshi-kotlin:$version_moshi\"\r\n\r\n    implementation \"com.squareup.retrofit2:retrofit:2.9.0\"\r\n\r\n    //Glide\r\n    implementation \"com.github.bumptech.glide:glide:4.8.0\"\r\n\r\n    implementation \"com.squareup.okhttp3:logging-interceptor:4.0.1\"\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle b/app/build.gradle
--- a/app/build.gradle	(revision f4679b71460dc01b6bd1244709d13b8f5a02b1e2)
+++ b/app/build.gradle	(date 1642294665249)
@@ -198,7 +198,7 @@
 
     // Retrofit Coroutines Support
     implementation "com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:$version_retrofit_coroutines_adapter"
-
+    kapt("com.squareup.moshi:moshi-kotlin-codegen:1.8.0")
     // Retrofit with Moshi Converter
     implementation "com.squareup.retrofit2:converter-moshi:$version_retrofit"
     // Moshi
Index: app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.ingredientlist\r\n\r\n//import androidx.test.core.app.ApplicationProvider\r\n\r\nimport android.app.Application\r\nimport android.content.Context\r\nimport android.net.ConnectivityManager\r\nimport android.net.NetworkCapabilities\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.lifecycle.*\r\nimport com.example.nutritionapp.database.IngredientDataClass\r\nimport com.example.nutritionapp.database.IngredientDataSourceInterface\r\nimport com.example.nutritionapp.database.dto.IngredientDataClassDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDomain\r\nimport com.example.nutritionapp.network.*\r\nimport com.example.nutritionapp.recipe.*\r\nimport com.example.nutritionapp.util.Result\r\nimport com.example.nutritionapp.util.wrapEspressoIdlingResource\r\nimport com.google.android.gms.maps.model.LatLng\r\nimport kotlinx.coroutines.*\r\nimport java.net.URLEncoder\r\nimport kotlinx.coroutines.flow.*\r\n\r\n/*\r\nTo get context inside a ViewModel we can either extend AndroidViewModel. Do not use ApplicationProvider in production code, only in tests\r\nhttps://stackoverflow.com/questions/51451819/how-to-get-context-in-android-mvvm-viewmodel\r\n */\r\n\r\nval selectedProductName = MutableLiveData<String>(\"Apple,flour,sugar\")\r\n\r\nclass IngredientViewModel(\r\n    val app: Application,\r\n    val ingredientRepository: IngredientDataSourceInterface, val nutritionApi: mNutritionApi\r\n) : AndroidViewModel(app) {\r\n\r\n//--------------------------------------------------------IngredientListOverview Fragment-----------------------------------------------\r\n    //Note: Don't set the MutableLiveData to null, b/c technically it is not initialized so any assignment will not change the null value\r\n    //and variable observing this MutableLiveData will return null\r\n\r\n    //flag for shopping cart image\r\n    private val _shoppingCartVisibilityFlag = MutableLiveData(true)\r\n    val shoppingCartVisibilityFlag: LiveData<Boolean>\r\n        get() = _shoppingCartVisibilityFlag\r\n\r\n    //flag for navigating once coroutine involving search recipe button in ingredientListFragment is finished\r\n    private val _navigatorFlag = MutableLiveData<Boolean>(false)\r\n    val navigatorFlag: LiveData<Boolean>\r\n        get() = _navigatorFlag\r\n\r\n    fun setNavigatorFlag(boolean: Boolean) {\r\n        _navigatorFlag.value = boolean\r\n    }\r\n\r\n    private val _viewVisibilityFlag = MutableStateFlow<Boolean>(false)\r\n    val viewVisibilityFlag: StateFlow<Boolean>\r\n        get() = _viewVisibilityFlag\r\n\r\n\r\n    private val _mutableLiveDataList: MutableLiveData<List<IngredientDataClass>> = MutableLiveData()\r\n    val mutableLiveDataList: MutableLiveData<List<IngredientDataClass>>\r\n        get() = _mutableLiveDataList\r\n\r\n    private val _networkResultStateFlow = MutableStateFlow<List<IngredientDataClass>?>(null)\r\n    val networkResultStateFlow : StateFlow<List<IngredientDataClass>?>\r\n    get() = _networkResultStateFlow\r\n\r\n    private val _listOfSavedIngredients = MutableStateFlow<List<IngredientDataClass>?>(null)\r\n    val listOfSavedIngredients: StateFlow<List<IngredientDataClass>?>\r\n    get() = _listOfSavedIngredients\r\n\r\n    //two-way binding\r\n    //no need to add \"?query=\" since the getIngredients() of the IngredientsApiInterface will do that\r\n    var searchItem = MutableLiveData<String>()\r\n\r\n    val foodInText = mutableListOf<String>()\r\n\r\n    private val _navigateToDetail = MutableLiveData<IngredientDataClass>()\r\n    val navigateToDetail: LiveData<IngredientDataClass>\r\n        get() = _navigateToDetail\r\n\r\n    fun setNavigateToDetail(ingredientItem: IngredientDataClass) {\r\n        selectedIngredient.value = ingredientItem\r\n        _quantityCounter.value = ingredientItem.quantity\r\n        _navigateToDetail.value = ingredientItem\r\n    }\r\n\r\n    fun setNavigateToDetailNull() {\r\n        _navigateToDetail.value = null\r\n    }\r\n\r\n    //--------------------------------------------------------mapGroceryReminder--------------------------------------------------------\r\n\r\n    private val _latLng = MutableLiveData<LatLng>()\r\n    val latLng: LiveData<LatLng>\r\n        get() = _latLng\r\n\r\n    fun setLatLng(latLng: LatLng) {\r\n        _latLng.value = latLng\r\n    }\r\n\r\n    private val _saveRecipeNotificationFlag = MutableLiveData(false)\r\n\r\n\r\n    //--------------------------------------------------------ingredientDetail Fragment ---------------------------------------------------\r\n    val selectedIngredient = MutableLiveData<IngredientDataClass>()\r\n\r\n    private val _quantityCounter = MutableLiveData<Int>(1)\r\n    val quantityCounter: LiveData<Int>\r\n        get() = _quantityCounter\r\n\r\n    fun increaseQuantityCounter() {\r\n        val temp = _quantityCounter.value?.plus(1)\r\n        _quantityCounter.value = temp\r\n        selectedIngredient.value?.quantity = temp!!\r\n    }\r\n\r\n    fun decreaseQuantityCounter() {\r\n        if (_quantityCounter.value!! > 0) {\r\n            //note - we need to reassign the mutableLiveData to a new variable for observers to observe a change in value\r\n            //you can't just update the existing value inside the mutableLiveData\r\n            val temp = _quantityCounter.value!!.minus(1)\r\n            _quantityCounter.value = temp\r\n            selectedIngredient.value?.quantity = temp\r\n        }\r\n    }\r\n\r\n    //--------------------------------------------------------recipeDetail Fragment ---------------------------------------------------\r\n    private val _missingIngredients = MutableLiveData<List<String>>()\r\n    val missingIngredients: LiveData<List<String>>\r\n        get() = _missingIngredients\r\n\r\n    private val _listOfStepsLiveData = MutableLiveData<List<String>>()\r\n    val listOfStepsLiveData: LiveData<List<String>>\r\n        get() = _listOfStepsLiveData\r\n\r\n    fun setMissingIngredientsNull() {\r\n        _missingIngredients.value = null\r\n    }\r\n\r\n    //--------------------------------------------------------SearchRecipe Fragment--------------------------------------------------------\r\n    //Q: Why does \"val listOfRecipesLiveData = MutableLiveData<List<RecipeIngredientResult>>(listOfRecipes)\" result in RecyclerView\r\n    //being empty?\r\n    //A: \"val listOfRecipesLiveData : MutableLiveData<List<RecipeIngredientResult>>? = null\" is explicitly setting the list<RecipeIngredientResult> value\r\n    //to null so that even if we add new values to the list<RecipeIngredientResult> the observers are not notified since MutableLiveData is still observing\r\n    //the same list. As such, you need to set a new list instead of updating the existing list since the list reference does not technically change when you\r\n    //add new values to the list so the observers are not notified. (?) \"MutableLiveData<List<RecipeIngredientResult>>()\" is correct because initially there\r\n    //is not value explicitly assigned to list<RecipeIngredientResult> so the first time a list is assigned the observers are signaled.\r\n    //A work around is offered at source: https://stackoverflow.com/questions/61834480/livedata-is-not-triggered-when-list-item-is-getting-updated\r\n\r\n\r\n    val _listOfRecipesLiveData = MutableLiveData<List<RecipeIngredientResult>>()\r\n    val listOfRecipesLiveData: LiveData<List<RecipeIngredientResult>>\r\n        get() = _listOfRecipesLiveData\r\n\r\n    val searchRecipeEditTextFlag = MutableLiveData(false)\r\n\r\n    fun setSearchRecipeEditTextClear() {\r\n        foodInText.clear()\r\n    }\r\n    //Two-way data binding\r\n    val listOfIngredientsString = MutableLiveData<String>()\r\n\r\n    private var _navigateToRecipeFlag = MutableLiveData(false)\r\n    val navigateToRecipeFlag: LiveData<Boolean>\r\n        get() = _navigateToRecipeFlag\r\n\r\n\r\n    private val _navigateToRecipe = MutableLiveData<RecipeIngredientResult>()\r\n    val navigateToRecipe: LiveData<RecipeIngredientResult>\r\n        get() = _navigateToRecipe\r\n\r\n    fun setNavigateToRecipe(recipe: RecipeIngredientResult) {\r\n        _navigateToRecipe.value = recipe\r\n    }\r\n\r\n    fun setNavigateToRecipeNull() {\r\n        _navigateToRecipe.value = null\r\n    }\r\n\r\n    fun setNavigateToRecipeFlag(boolean: Boolean) {\r\n        _navigateToRecipeFlag.value = boolean\r\n    }\r\n\r\n\r\n    //input is list of names i.e {\"Snapple Apple flavored drink 4oz\",\"Mott's Apple pudding 3oz\"}\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun detectFoodInText(listName: List<String>) {\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                _viewVisibilityFlag.value = true\r\n                try {\r\n                    for (i in listName) {\r\n                        //Note: For a post request, you can either provide a request body, passing in your text to the request body or you\r\n                        //can provide a text parameter within the suspend function in your API Interface.\r\n                        selectedProductName.value = URLEncoder.encode(i, \"utf-8\").toString()\r\n                        nutritionApi.setBody()\r\n                        Log.i(\"testURLEncoded: \", selectedProductName.value.toString())\r\n                        val listOfIngredients: PostRequestResultWrapper =\r\n                            nutritionApi.nutritionServicePost.detectFoodInText(\r\n                            )\r\n                        for (g in listOfIngredients.annotations) {\r\n                            Log.i(\"testURLAnnotation\", g.annotation)\r\n                            foodInText.add(g.annotation)\r\n                        }\r\n                    }\r\n                } catch (e: java.lang.Exception) {\r\n                    if (!isOnline(app)) {\r\n                        displayToast(\"Not connected to internet\")\r\n                    }\r\n                    Log.i(\"Exception\", \"$e\")\r\n                }\r\n\r\n                if (!foodInText.isEmpty()) {\r\n                    listOfIngredientsString.value = foodInText.joinToString(separator = \",\")\r\n                    _navigatorFlag.value = true\r\n                }\r\n                _viewVisibilityFlag.value = false\r\n            }\r\n        }\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun findRecipeByIngredients() {\r\n        val listOfRecipes = mutableListOf<RecipeIngredientResult>()\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                _viewVisibilityFlag.value = true\r\n                try {\r\n                    val resultWrapper: List<RecipeIngredientResult> =\r\n                        nutritionApi.nutritionService.findByIngredients(\r\n                            listOfIngredientsString.value!!\r\n                        )\r\n                    Log.i(\"testRecipeById\", \"recipe list size: ${resultWrapper.size}\")\r\n                    Log.i(\"testRecipeById\", \"recipe[0]: ${resultWrapper[0].title}\")\r\n                    for (i in resultWrapper) {\r\n                        listOfRecipes.add(i)\r\n                    }\r\n\r\n                    _listOfRecipesLiveData.value = listOfRecipes\r\n\r\n                } catch (e: java.lang.Exception) {\r\n                    if (!isOnline(app)) {\r\n                        displayToast(\"Not connected to internet\")\r\n                    }\r\n\r\n                    Log.i(\"Exception\", \"$e\")\r\n                }\r\n                _viewVisibilityFlag.value = false\r\n            }\r\n        }\r\n    }\r\n\r\n    //source: https://stackoverflow.com/questions/51141970/check-internet-connectivity-android-in-kotlin\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun isOnline(context: Context): Boolean {\r\n        val connectivityManager =\r\n            context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\r\n\r\n        val capabilities =\r\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {\r\n                Log.i(\"test\", \">M\")\r\n                connectivityManager.getNetworkCapabilities(connectivityManager.activeNetwork)\r\n            } else {\r\n                TODO(\"VERSION.SDK_INT < M\")\r\n            }\r\n        if (capabilities != null) {\r\n            if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {\r\n                Log.i(\"Internet\", \"NetworkCapabilities.TRANSPORT_CELLULAR\")\r\n                return true\r\n            } else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {\r\n                Log.i(\"Internet\", \"NetworkCapabilities.TRANSPORT_WIFI\")\r\n                return true\r\n            } else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) {\r\n                Log.i(\"Internet\", \"NetworkCapabilities.TRANSPORT_ETHERNET\")\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun loadIngredientListByNetwork() {\r\n        wrapEspressoIdlingResource {\r\n            Log.i(\"viewModel\",\"load called\")\r\n            viewModelScope.launch {\r\n                _viewVisibilityFlag.value = (true)\r\n                if (searchItem.value != null) {\r\n                    try {\r\n                        val result: wrapperIngredientListNetworkDataClass =\r\n                            nutritionApi.nutritionService.getIngredients(searchItem.value!!)\r\n                        Log.i(\"test\", \"search item: ${searchItem.value}\")\r\n                        Log.i(\"test1\", \"Total products: ${result}\")\r\n\r\n                        _mutableLiveDataList.value = result.toDomainType()\r\n\r\n                        _networkResultStateFlow.value = result.toDomainType()\r\n                        Log.i(\"viewModelMutable\", networkResultStateFlow.value!![0].name)\r\n\r\n                        Toast.makeText(\r\n                            app,\r\n                            \"Success\",\r\n                            Toast.LENGTH_SHORT\r\n                        ).show()\r\n\r\n                        val tempBool = false\r\n                        _shoppingCartVisibilityFlag.postValue(tempBool)\r\n\r\n                    } catch (e: Exception) {\r\n\r\n                        if (!isOnline(app)) {\r\n                            displayToast(\"Not connected to internet\")\r\n                        }\r\n                        println(\"Error: ${e.message}\")\r\n                    }\r\n                }\r\n                _viewVisibilityFlag.value = (false)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun displayToast(mString: String) {\r\n        Toast.makeText(\r\n            app,\r\n            mString,\r\n            Toast.LENGTH_SHORT\r\n        ).show()\r\n    }\r\n\r\n    fun saveRecipeNotification(recipeNotificationClassDomain: RecipeNotificationClassDomain) {\r\n\r\n        viewModelScope.launch {\r\n            ingredientRepository.saveNotificationRecipe(\r\n                RecipeNotificationClassDomain(\r\n                    recipeName = recipeNotificationClassDomain.recipeName,\r\n                    missingIngredients = recipeNotificationClassDomain.missingIngredients,\r\n                    mId = recipeNotificationClassDomain.mId\r\n                )\r\n            )\r\n            _saveRecipeNotificationFlag.value = true\r\n        }\r\n    }\r\n\r\n    val mFlag = MutableLiveData(false)\r\n    fun getRecipeInstructions() {\r\n        val listOfIngredientNameInInstruction = mutableListOf<String>()\r\n\r\n        val listOfSteps = mutableListOf<String>()\r\n\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n\r\n                //Note: So the issue here was that the coroutine has not finished running. The solution was to make the network request function a\r\n                // regular function to make it blocking Since the network function was initially a suspend function, the rest of the code was\r\n                // proceeding under the assumption that \"resultInstructions\" was null. Even if \"resultInstructions\" returns a value the rest\r\n                // of the code logic had already ran. So the solution was to make \"resultInstructions\" blocking.\r\n\r\n                //Coroutines execute synchronously so the CoroutineScope of the Main thread will ensure that the job in Dispatchers.IO is\r\n                //finished first before proceeding.\r\n                //avoids NetworkOnMainThread exception error by running on a non-Main thread\r\n                //Q: Why is this working but not the previous network request format?\r\n                val networkResult: List<RecipeInstruction>? =\r\n                    _navigateToRecipe.value?.id?.let {\r\n                        nutritionApi.nutritionService.getRecipeInstructions(it, false)\r\n                    }\r\n\r\n                //iterates over each sub recipe i.e recipe for cake and recipe for frosting\r\n                if (!networkResult.isNullOrEmpty()) {\r\n                    for (i in networkResult) {\r\n                        //adds title of sub recipes i.e frosting recipe in a cake recipe\r\n                        if (i.name?.length!! > 0)\r\n                            listOfSteps.add(i.name)\r\n\r\n                        //iterates over \"RecipeInstruction\" to add the instructions steps into a list\r\n                        for (steps in i.steps!!) {\r\n                            //collects the ingredients mentioned in the recipe instructions\r\n                            for (name in steps.ingredients!!) {\r\n                                if (!name.name.isNullOrEmpty()) {\r\n                                    listOfIngredientNameInInstruction.add(name.name)\r\n                                }\r\n                            }\r\n                            steps.step?.let { listOfSteps.add(it) }\r\n                        }\r\n                    }\r\n\r\n                    _listOfStepsLiveData.value = listOfSteps\r\n                    val removeDuplicates = listOfIngredientNameInInstruction.toSet().toList()\r\n                    _missingIngredients.value = removeDuplicates.minus(\r\n                        foodInText\r\n                    )\r\n                    mFlag.value = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun saveIngredientItem() {\r\n        if (selectedIngredient.value != null && selectedIngredient.value?.quantity!! >= 0) {\r\n            wrapEspressoIdlingResource {\r\n                viewModelScope.launch {\r\n                    selectedIngredient.value?.let { ingredientRepository.saveNewIngredient(it) }\r\n                }\r\n            }\r\n        } else\r\n            Toast.makeText(app, \"Invalid quantity\", Toast.LENGTH_SHORT).show()\r\n    }\r\n\r\n    fun getLocalIngredientList() { //need DAO and repository\r\n        Log.i(\"test\", \"getLocalList called\")\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n\r\n                val ingredientResult: Result<List<IngredientDataClassDTO>> =\r\n                    ingredientRepository.getIngredients()\r\n                when (ingredientResult) {\r\n                    is Result.Success<*> -> {\r\n                        val dataList = ArrayList<IngredientDataClass>()\r\n                        dataList.addAll((ingredientResult.data as List<IngredientDataClassDTO>).map { result ->\r\n                            //map the reminder data from the DB to the be ready to be displayed on the UI\r\n                            IngredientDataClass(\r\n                                id = result.id,\r\n                                name = result.name,\r\n                                quantity = result.quantity,\r\n                                imageUrl = result.image,\r\n                                imageType = result.imageType\r\n                            )\r\n                        })\r\n                        _listOfSavedIngredients.value = (dataList)\r\n                    }\r\n                    is Result.Error -> {\r\n                        Log.i(\"test\", \"empty repository\")\r\n//                Toast.makeText(ApplicationProvider.getApplicationContext(),\"${ingredientResult.message}\",Toast.LENGTH_SHORT).show()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun clearRecipeNotificationTable() {\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                ingredientRepository.clearNotificationRecipe()\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    override fun onCleared() {\r\n        super.onCleared()\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt b/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt
--- a/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt	(revision f4679b71460dc01b6bd1244709d13b8f5a02b1e2)
+++ b/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt	(date 1642295228250)
@@ -17,12 +17,14 @@
 import com.example.nutritionapp.maps.RecipeNotificationClassDomain
 import com.example.nutritionapp.network.*
 import com.example.nutritionapp.recipe.*
+//import com.example.nutritionapp.recipe.intolerancespinnerclasses.IntoleraceDataType
 import com.example.nutritionapp.util.Result
 import com.example.nutritionapp.util.wrapEspressoIdlingResource
 import com.google.android.gms.maps.model.LatLng
 import kotlinx.coroutines.*
 import java.net.URLEncoder
 import kotlinx.coroutines.flow.*
+import timber.log.Timber
 
 /*
 To get context inside a ViewModel we can either extend AndroidViewModel. Do not use ApplicationProvider in production code, only in tests
@@ -160,8 +162,9 @@
     fun setSearchRecipeEditTextClear() {
         foodInText.clear()
     }
+
     //Two-way data binding
-    val listOfIngredientsString = MutableLiveData<String>()
+    val ingredientToBeAddedAsChip = MutableLiveData<String>()
 
     private var _navigateToRecipeFlag = MutableLiveData(false)
     val navigateToRecipeFlag: LiveData<Boolean>
@@ -184,7 +187,15 @@
         _navigateToRecipeFlag.value = boolean
     }
 
+    val arrayOfRecipeFilterOptions = arrayListOf<String>("none","pescetarian", "lacto vegetarian", "ovo vegetarian", "vegan", "vegetarian")
 
+    /*val arrayOfIntolerance = arrayListOf<IntoleraceDataType>(IntoleraceDataType("dairy"), IntoleraceDataType("egg"), IntoleraceDataType("gluten"),
+        IntoleraceDataType("peanut"), IntoleraceDataType("sesame"), IntoleraceDataType("seafood"),
+        IntoleraceDataType("shellfish"), IntoleraceDataType("soy"), IntoleraceDataType("sulfite"),
+        IntoleraceDataType("tree nut"), IntoleraceDataType("wheat"))
+*/
+    val selectedFilter = MutableStateFlow("")
+    var selectedIntolerance : String = ""
     //input is list of names i.e {"Snapple Apple flavored drink 4oz","Mott's Apple pudding 3oz"}
     @RequiresApi(Build.VERSION_CODES.LOLLIPOP)
     fun detectFoodInText(listName: List<String>) {
@@ -214,7 +225,9 @@
                 }
 
                 if (!foodInText.isEmpty()) {
-                    listOfIngredientsString.value = foodInText.joinToString(separator = ",")
+
+                    //listOfIngredientsString.value = foodInText.joinToString(separator = ",")
+
                     _navigatorFlag.value = true
                 }
                 _viewVisibilityFlag.value = false
@@ -229,24 +242,32 @@
             viewModelScope.launch {
                 _viewVisibilityFlag.value = true
                 try {
+                    Log.i("test","selectedFilter ${selectedFilter.value}")
+                    Log.i("test","intolerance: ${selectedIntolerance}")
+                    Log.i("test","foodInText: ${foodInText.joinToString(separator = ",").replace("[","")
+                        .replace("]","")}")
+                    val tempSelectedFilter = selectedFilter.value
+                    val tempFoodInText =  foodInText.joinToString(separator = ",").replace("[","")
+                        .replace("]","")
                     val resultWrapper: List<RecipeIngredientResult> =
                         nutritionApi.nutritionService.findByIngredients(
-                            listOfIngredientsString.value!!
-                        )
-                    Log.i("testRecipeById", "recipe list size: ${resultWrapper.size}")
-                    Log.i("testRecipeById", "recipe[0]: ${resultWrapper[0].title}")
+                            tempSelectedFilter, selectedIntolerance,
+                           tempFoodInText)
+                    Log.i("test","size test: ${resultWrapper.size}")
+                    Log.i("test","[0]: ${resultWrapper[0].title}")
+                    Timber.i("recipe list size: " + resultWrapper.size)
+                    Timber.i("recipe[0]: " + resultWrapper[0].title)
                     for (i in resultWrapper) {
                         listOfRecipes.add(i)
                     }
-
                     _listOfRecipesLiveData.value = listOfRecipes
-
+                } catch (e: java.lang.Exception) {
                 } catch (e: java.lang.Exception) {
                     if (!isOnline(app)) {
                         displayToast("Not connected to internet")
                     }
 
-                    Log.i("Exception", "$e")
+                    Timber.i(e)
                 }
                 _viewVisibilityFlag.value = false
             }
@@ -365,7 +386,7 @@
                 //Q: Why is this working but not the previous network request format?
                 val networkResult: List<RecipeInstruction>? =
                     _navigateToRecipe.value?.id?.let {
-                        nutritionApi.nutritionService.getRecipeInstructions(it, false)
+                        nutritionApi.nutritionService.getRecipeInstructions(it.toString(), false)
                     }
 
                 //iterates over each sub recipe i.e recipe for cake and recipe for frosting
Index: app/src/main/java/com/example/nutritionapp/network/NutritionAPI.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.network\r\n\r\nimport android.util.Log\r\nimport androidx.annotation.VisibleForTesting\r\nimport com.example.nutritionapp.ingredientlist.selectedProductName\r\nimport com.example.nutritionapp.recipe.PostRequestResultWrapper\r\nimport com.example.nutritionapp.recipe.RecipeIngredientResult\r\nimport com.example.nutritionapp.recipe.RecipeInstruction\r\nimport com.squareup.moshi.Moshi\r\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\r\nimport okhttp3.*\r\nimport okhttp3.MediaType.Companion.toMediaTypeOrNull\r\nimport okhttp3.logging.HttpLoggingInterceptor\r\nimport retrofit2.Call\r\nimport retrofit2.Retrofit\r\nimport retrofit2.converter.moshi.MoshiConverterFactory\r\nimport retrofit2.http.*\r\nimport java.io.IOException\r\n\r\nprivate const val BASE_URL = \"https://spoonacular-recipe-food-nutrition-v1.p.rapidapi.com/\"\r\n\r\nopen class mNutritionApi {\r\n\r\n\r\n    val mediaType = \"application/x-www-form-urlencoded\".toMediaTypeOrNull()\r\n\r\n    //Q: What is the purpose of \".post(body)\" in the OkHttpClient?\r\n//A: To input your text that will be acted upon by the API POST function\r\n    var body: RequestBody? = null\r\n    fun setBody() {\r\n        body = RequestBody.create(\r\n            mediaType,\r\n            \"text=${selectedProductName.value}\"\r\n        )\r\n        Log.i(\"testSetBody()\", selectedProductName.value.toString())\r\n    }\r\n\r\n    //Note: Need to add MediaType\r\n    val clientPostRequest by lazy {\r\n        OkHttpClient.Builder().addInterceptor(object : Interceptor {\r\n            @Throws(IOException::class)\r\n            override fun intercept(chain: Interceptor.Chain): okhttp3.Response {\r\n                val newRequest: Request = chain.request().newBuilder()\r\n                    .post(body!!)\r\n                    .addHeader(\"content-type\", \"application/x-www-form-urlencoded\")\r\n                    .addHeader(\"x-rapidapi-host\", \"spoonacular-recipe-food-nutrition-v1.p.rapidapi.com\")\r\n                    .addHeader(\r\n                        \"x-rapidapi-key\",\r\n                        \"743dd97869msh559abee3f899bd4p131dd1jsn866e00036c54\"\r\n                    )//Error: HTTP 401 Unauthorized\r\n                    .build()\r\n                return chain.proceed(newRequest)\r\n            }\r\n        }).build()\r\n    }\r\n\r\n    private val retrofitPost by lazy {\r\n        Retrofit.Builder()\r\n            .addConverterFactory(MoshiConverterFactory.create(moshi))\r\n            .baseUrl(BASE_URL)\r\n            .client(clientPostRequest)\r\n            .build()\r\n    }\r\n    /**\r\n     * Build the Moshi object that Retrofit will be using, making sure to add the Kotlin adapter for\r\n     * full Kotlin compatibility.\r\n     */\r\n\r\n    private val moshi = Moshi.Builder()\r\n        .add(KotlinJsonAdapterFactory())\r\n        .build()\r\n\r\n/*\r\nAn interceptor will intercept the HTTP request and append the headers when Retrofit is initialized\r\nso that we don't have to append the headers for every call\r\nsource: https://stackoverflow.com/questions/41078866/retrofit2-authorization-global-interceptor-for-access-token/41082979#41082979\r\nsource: https://stackoverflow.com/questions/42491733/passing-api-key-in-retrofit-2-android-studio\r\n\r\n Q: Why do we add a \"Header\"?\r\n A: A request header is an HTTP header that can be used in an HTTP request to provide information about the request context,\r\n so that the server can tailor the response (source:https://developer.mozilla.org/en-US/docs/Glossary/Request_header)\r\n */\r\n\r\n\r\n    //Separate client and Retrofit object for @GET and @POST requests since they have different headers\r\n//                .addHeader(\"content-type\", \"application/json\")\r\n\r\n\r\n    var clientGetRequest = OkHttpClient.Builder().addInterceptor(object : Interceptor {\r\n        @Throws(IOException::class)\r\n        override fun intercept(chain: Interceptor.Chain): Response {\r\n\r\n            val newRequest: Request = chain.request().newBuilder()\r\n                .get()\r\n                .addHeader(\"x-rapidapi-host\", \"spoonacular-recipe-food-nutrition-v1.p.rapidapi.com\")\r\n                .addHeader(\r\n                    \"x-rapidapi-key\",\r\n                    \"743dd97869msh559abee3f899bd4p131dd1jsn866e00036c54\"\r\n                )//Error: HTTP 401 Unauthorized\r\n                .build()\r\n\r\n            return chain.proceed(newRequest)\r\n        }\r\n\r\n    }).build()\r\n\r\n      val retrofit = Retrofit.Builder()\r\n        .addConverterFactory(MoshiConverterFactory.create(moshi))\r\n        .baseUrl(BASE_URL)\r\n        .client(clientGetRequest)\r\n        .build()\r\n\r\n    val nutritionService: IngredientsApiInterface by lazy {\r\n        retrofit.create(IngredientsApiInterface::class.java)\r\n    }\r\n\r\n    val nutritionServicePost: IngredientsApiInterface by lazy {\r\n        retrofitPost.create(\r\n            IngredientsApiInterface::class.java\r\n        )\r\n    }\r\n}\r\n    /**\r\n     * A public interface that exposes the [getIngredients] method\r\n     */\r\n    interface IngredientsApiInterface {\r\n        /**\r\n         * Returns a Coroutine [List] of [Ingredients] which can be fetched with await() if in a Coroutine scope.\r\n         * The @GET annotation indicates that the \"realestate\" endpoint will be requested with the GET\r\n         * HTTP method\r\n         */\r\n\r\n        //Note: \"query\" is what will be appended to the end point i.e http.somesite.com/search?query=\r\n        @GET(\"food/products/search\")\r\n        suspend fun getIngredients(@Query(\"query\") type: String): wrapperIngredientListNetworkDataClass\r\n\r\n        @GET(\"recipes/findByIngredients\")\r\n        suspend fun findByIngredients(@Query(\"ingredients\") list: String): List<RecipeIngredientResult>\r\n\r\n        //run as blocking function by omitting suspend modifier\r\n        @GET(\"recipes/{id}/analyzedInstructions\")\r\n        suspend fun getRecipeInstructions(@Path(\"id\") id : Long, @Query(\"stepBreakdown\") boolean: Boolean) : List<RecipeInstruction>\r\n\r\n        @POST(\"food/detect\")\r\n        suspend fun detectFoodInText(): PostRequestResultWrapper\r\n    }\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/network/NutritionAPI.kt b/app/src/main/java/com/example/nutritionapp/network/NutritionAPI.kt
--- a/app/src/main/java/com/example/nutritionapp/network/NutritionAPI.kt	(revision f4679b71460dc01b6bd1244709d13b8f5a02b1e2)
+++ b/app/src/main/java/com/example/nutritionapp/network/NutritionAPI.kt	(date 1642294686765)
@@ -96,7 +96,7 @@
                 .addHeader(
                     "x-rapidapi-key",
                     "743dd97869msh559abee3f899bd4p131dd1jsn866e00036c54"
-                )//Error: HTTP 401 Unauthorized
+                )//Error: HTTP 401 Unauthorize
                 .build()
 
             return chain.proceed(newRequest)
@@ -134,12 +134,14 @@
         @GET("food/products/search")
         suspend fun getIngredients(@Query("query") type: String): wrapperIngredientListNetworkDataClass
 
-        @GET("recipes/findByIngredients")
-        suspend fun findByIngredients(@Query("ingredients") list: String): List<RecipeIngredientResult>
+        //diet={diet}&intolerance={intolerance}&includeIngredients={includeIngredients}")
+        @GET("recipes/complexSearch")
+        suspend fun findByIngredients(@Query("diet") diet : String, @Query("intolerance") intolerance : String,
+                                      @Query("includeIngredients") includeIngredients : String): List<RecipeIngredientResult>
 
         //run as blocking function by omitting suspend modifier
         @GET("recipes/{id}/analyzedInstructions")
-        suspend fun getRecipeInstructions(@Path("id") id : Long, @Query("stepBreakdown") boolean: Boolean) : List<RecipeInstruction>
+        suspend fun getRecipeInstructions(@Path("id") id : String, @Query("stepBreakdown") boolean: Boolean) : List<RecipeInstruction>
 
         @POST("food/detect")
         suspend fun detectFoodInText(): PostRequestResultWrapper
Index: app/src/main/java/com/example/nutritionapp/recipe/RecipeDataClass.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.recipe\r\n\r\nimport com.squareup.moshi.Json\r\nimport java.io.Serializable\r\n\r\n//recipe ingredients\r\n//Note: When the returning JSON object is an array at it's outer most layer, then you do not need a wrapper class for that array\r\n//Instead, you result could be as such: val result = List<DataType>\r\ndata class RecipeIngredientResult (val id : Long, val title : String, val image : String, val usedIngredientCount : Int,\r\n                                   val missedIngredientCount : Int, val likes : Int) : Serializable\r\n\r\n//recipe steps\r\n\r\n//data class RecipeInstructionsWrapper(val mList : List<RecipeInstruction>) //unnecessary\r\n\r\ndata class RecipeInstruction(@Json(name = \"name\")val name : String?, @Json(name = \"steps\") val steps : List<RecipeInstructionSteps>?)\r\n\r\ndata class RecipeInstructionSteps(val number: Int?, val step: String?, val ingredients : List<ingredientsAndEquipment>?,\r\nval equipment : List<ingredientsAndEquipment>?, val Length : Length?)\r\n\r\ndata class ingredientsAndEquipment(val id : Long?, val name : String?, val localizedName : String?, val image : String?,\r\n                                   val temperature : Temperature?)\r\n\r\ndata class Temperature(val temperature : Int?, val unitMeasurement : String?)\r\n\r\ndata class Length(val number : Int?, val unitMeasurement: String?)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/recipe/RecipeDataClass.kt b/app/src/main/java/com/example/nutritionapp/recipe/RecipeDataClass.kt
--- a/app/src/main/java/com/example/nutritionapp/recipe/RecipeDataClass.kt	(revision f4679b71460dc01b6bd1244709d13b8f5a02b1e2)
+++ b/app/src/main/java/com/example/nutritionapp/recipe/RecipeDataClass.kt	(date 1642294691040)
@@ -6,9 +6,14 @@
 //recipe ingredients
 //Note: When the returning JSON object is an array at it's outer most layer, then you do not need a wrapper class for that array
 //Instead, you result could be as such: val result = List<DataType>
-data class RecipeIngredientResult (val id : Long, val title : String, val image : String, val usedIngredientCount : Int,
-                                   val missedIngredientCount : Int, val likes : Int) : Serializable
-
+data class RecipeIngredientResult (val id : Int, val title : String, val image : String, val imageType : String) : Serializable
+/*"id":268411
+"usedIngredientCount":2
+"missedIngredientCount":1
+"likes":0
+"title":"Zesty Tomato Sauce"
+"image":"https://spoonacular.com/recipeImages/268411-312x231.jpg"
+"imageType":"jpg"*/
 //recipe steps
 
 //data class RecipeInstructionsWrapper(val mList : List<RecipeInstruction>) //unnecessary
Index: app/src/main/java/com/example/nutritionapp/recipe/SearchRecipe.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.recipe\r\n\r\nimport android.os.Build\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport androidx.activity.OnBackPressedCallback\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.databinding.DataBindingUtil\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.lifecycle.Observer\r\nimport androidx.navigation.fragment.findNavController\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport com.example.nutritionapp.R\r\nimport com.example.nutritionapp.databinding.RecipeLayoutBinding\r\nimport com.example.nutritionapp.ingredientlist.IngredientViewModel\r\nimport org.koin.android.ext.android.inject\r\nimport org.koin.androidx.viewmodel.ext.android.sharedViewModel\r\nimport timber.log.Timber\r\n\r\nclass SearchRecipe : Fragment() {\r\nprivate lateinit var binding : RecipeLayoutBinding\r\n//viewModel is being initialized before the detectFoodText is done running in the background\r\n //val viewModel by lazy { ViewModelProvider(this).get(IngredientViewModel::class.java)}\r\n\r\nprivate val adapter = recipeAdapter(recipeAdapter.RecipeIngredientListener { recipe ->\r\n    Timber.i(\"Recipe selected name: \" + recipe.title)\r\n    viewModel.setNavigateToRecipe(recipe)\r\n    viewModel.setNavigateToRecipeFlag(true)\r\n    //need a seperate flag\r\n})\r\n\r\nval viewModel by sharedViewModel<IngredientViewModel>()\r\n\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n         super.onCreateView(inflater, container, savedInstanceState)\r\n        //Q: How to inflate layout object in onViewCreated?\r\n        //val args = SearchRecipeArgs.fromBundle(requireArguments()).ListOfIngredients//arguments?.getString(\"ListOfIngredients\")\r\n        //Log.i(\"test\",\"args: $args\")\r\n\r\n        binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.recipe_layout, container,false)\r\n\r\n        binding.viewModel = viewModel\r\n\r\n        binding.searchRecipeButton.setOnClickListener {\r\n            viewModel.findRecipeByIngredients()}\r\n\r\n        binding.recipeRecyclerView.layoutManager = LinearLayoutManager(context)\r\n\r\n        binding.recipeRecyclerView.adapter = adapter\r\n\r\n        viewModel.listOfRecipesLiveData?.observe(viewLifecycleOwner, Observer{\r\n            adapter.submitList(it)\r\n        })\r\n\r\n        viewModel.navigateToRecipeFlag.observe(viewLifecycleOwner, Observer {\r\n            if (it) {\r\n                    viewModel.getRecipeInstructions()\r\n                //Placing the navigation step outside of the flag results in the destination fragment's viewModel\r\n                // not having the updated value.\r\n                //Resolved: https://knowledge.udacity.com/questions/737289\r\n                Log.i(\"test\",\"food in text size: ${viewModel.foodInText.size}\")\r\n                //Once getRecipeInstructions() is complete it will set mFlag = true so that navigation happens only after the liveData in getRecipeInstructions is updated\r\n                viewModel.mFlag.observe(viewLifecycleOwner, Observer {\r\n                    if (it) {\r\n                        findNavController().navigate(\r\n                            SearchRecipeDirections.actionSearchRecipeToRecipeDetail(\r\n                                viewModel.navigateToRecipe.value!!))\r\n                        viewModel.setNavigateToRecipeFlag(false)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        )\r\n\r\n        //source: https://stackoverflow.com/questions/55074497/how-to-add-onbackpressedcallback-to-fragment\r\n        requireActivity()\r\n            .onBackPressedDispatcher\r\n            .addCallback(viewLifecycleOwner, object : OnBackPressedCallback(true) {\r\n                override fun handleOnBackPressed() {\r\n                    Log.i(\"test\",\"SearchRecipe on back pressed\")\r\n                    viewModel.searchRecipeEditTextFlag.value = true\r\n                    // if you want onBackPressed() to be called as normal afterwards\r\n                    if (isEnabled) {\r\n                        isEnabled = false\r\n                        requireActivity().onBackPressed()\r\n                    }\r\n                }\r\n            }\r\n            )\r\n        return binding.root\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        viewModel.setMissingIngredientsNull()\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/recipe/SearchRecipe.kt b/app/src/main/java/com/example/nutritionapp/recipe/SearchRecipe.kt
--- a/app/src/main/java/com/example/nutritionapp/recipe/SearchRecipe.kt	(revision f4679b71460dc01b6bd1244709d13b8f5a02b1e2)
+++ b/app/src/main/java/com/example/nutritionapp/recipe/SearchRecipe.kt	(date 1642294694931)
@@ -6,6 +6,8 @@
 import android.view.LayoutInflater
 import android.view.View
 import android.view.ViewGroup
+import android.widget.AdapterView
+import android.widget.ArrayAdapter
 import androidx.activity.OnBackPressedCallback
 import androidx.annotation.RequiresApi
 import androidx.databinding.DataBindingUtil
@@ -16,7 +18,8 @@
 import com.example.nutritionapp.R
 import com.example.nutritionapp.databinding.RecipeLayoutBinding
 import com.example.nutritionapp.ingredientlist.IngredientViewModel
-import org.koin.android.ext.android.inject
+import com.example.nutritionapp.recipe.intolerancespinnerclasses.IntoleranceAdapter
+import com.google.android.material.chip.Chip
 import org.koin.androidx.viewmodel.ext.android.sharedViewModel
 import timber.log.Timber
 
@@ -49,30 +52,116 @@
 
         binding.viewModel = viewModel
 
+        val intoleranceAdapter = IntoleranceAdapter(requireContext(),R.layout.intolerance_option_item, R.id.intolerance_name, viewModel.arrayOfIntolerance)
+
         binding.searchRecipeButton.setOnClickListener {
-            viewModel.findRecipeByIngredients()}
+            for (item in viewModel.arrayOfIntolerance)
+            {
+                item.isChecked = false
+            }
+            viewModel.selectedIntolerance = intoleranceAdapter.selectedIntoleranceList.toString()
+                .replace("[","").replace("]","")
+
+            intoleranceAdapter.selectedIntoleranceList
+            Timber.i("searchRecipeButton clicked")
+            viewModel.findRecipeByIngredients()
+        }
 
         binding.recipeRecyclerView.layoutManager = LinearLayoutManager(context)
 
         binding.recipeRecyclerView.adapter = adapter
 
+        //for creating the chips from the selected ingredients
+        if (!viewModel.foodInText.isEmpty()) {
+            for (i in viewModel.foodInText) {
+                val mChip = Chip(binding.chipGroupView.context)
+                mChip.text = i
+                //mChip.explicitStyle = R.color.chip_color
+                mChip.isClickable = true
+                mChip.isCheckable = true
+                mChip.isCloseIconVisible = true
+
+                mChip.setOnCloseIconClickListener {
+                    binding.chipGroupView.removeView(it)
+                    viewModel.foodInText.remove(mChip.text)
+                }
+                binding.chipGroupView.addView(mChip)
+            }
+        }
+        //adds new chips
+        binding.addChipButton.setOnClickListener {
+            if (viewModel.ingredientToBeAddedAsChip.value.isNullOrEmpty() == false) {
+
+                    val mChip = Chip(binding.chipGroupView.context)
+                    mChip.text = viewModel.ingredientToBeAddedAsChip.value
+                    //mChip.explicitStyle = R.color.chip_color
+                    mChip.isClickable = true
+                    mChip.isCheckable = true
+                    mChip.isCloseIconVisible = true
+                    val addIngredient = viewModel.ingredientToBeAddedAsChip.value
+                    viewModel.foodInText.add(addIngredient!!)
+                    mChip.setOnCloseIconClickListener {
+                        binding.chipGroupView.removeView(it)
+                        viewModel.foodInText.remove(mChip.text)
+                    }
+                    binding.chipGroupView.addView(mChip)
+                }
+        }
+
+        binding.recipeOptionsSpinner.adapter = ArrayAdapter(this.requireContext(),R.layout.support_simple_spinner_dropdown_item,viewModel.arrayOfRecipeFilterOptions)
+
+        //implementation from: https://www.youtube.com/watch?v=D5l7MNlqA3M&ab_channel=CodeAndroid
+        binding.recipeOptionsSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener{
+            override fun onItemSelected(
+                parent: AdapterView<*>?,
+                view: View?,
+                position: Int,
+                id: Long
+            ) {
+                viewModel.selectedFilter.value = viewModel.arrayOfRecipeFilterOptions[position]
+            }
+
+            override fun onNothingSelected(parent: AdapterView<*>?) {
+            }
+
+        }
+
+        binding.intoleranceOptionsSpiner.adapter = intoleranceAdapter//ArrayAdapter(this.requireContext(),R.layout.support_simple_spinner_dropdown_item, R.id.intolerance_name, viewModel.arrayOfIntolerance)
+
+        binding.intoleranceOptionsSpiner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener{
+            override fun onItemSelected(
+                parent: AdapterView<*>?,
+                view: View?,
+                position: Int,
+                id: Long
+            ) {
+
+            }
+
+            override fun onNothingSelected(parent: AdapterView<*>?) {
+                TODO("Not yet implemented")
+            }
+
+        }
         viewModel.listOfRecipesLiveData?.observe(viewLifecycleOwner, Observer{
             adapter.submitList(it)
         })
 
         viewModel.navigateToRecipeFlag.observe(viewLifecycleOwner, Observer {
             if (it) {
-                    viewModel.getRecipeInstructions()
+                viewModel.getRecipeInstructions()
                 //Placing the navigation step outside of the flag results in the destination fragment's viewModel
                 // not having the updated value.
                 //Resolved: https://knowledge.udacity.com/questions/737289
-                Log.i("test","food in text size: ${viewModel.foodInText.size}")
+                Timber.i("food in text size: " + viewModel.foodInText.size)
                 //Once getRecipeInstructions() is complete it will set mFlag = true so that navigation happens only after the liveData in getRecipeInstructions is updated
                 viewModel.mFlag.observe(viewLifecycleOwner, Observer {
                     if (it) {
                         findNavController().navigate(
                             SearchRecipeDirections.actionSearchRecipeToRecipeDetail(
-                                viewModel.navigateToRecipe.value!!))
+                                viewModel.navigateToRecipe.value!!
+                            )
+                        )
                         viewModel.setNavigateToRecipeFlag(false)
                     }
                 })
