Index: app/src/main/java/com/example/nutritionapp/database/IngredientDao.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.database\r\n\r\nimport androidx.room.*\r\nimport com.example.nutritionapp.database.dto.IngredientDataClassDTO\r\nimport androidx.room.Dao\r\nimport androidx.room.Insert\r\nimport androidx.room.OnConflictStrategy\r\nimport androidx.room.Query\r\nimport com.example.nutritionapp.database.dto.RecipeOfDayDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDTO\r\nimport com.example.nutritionapp.network.RecipeOfDayNetworkClassCondensed\r\n\r\n@Dao\r\ninterface IngredientDao {\r\n\r\n/*    @Insert\r\n    suspend fun insert(ingredient: IngredientDataClassDTO)*/\r\n\r\n    /**\r\n     * When updating a row with a value already set in a column,\r\n     * replaces the old value with the new one.\r\n     *\r\n     * @param ingredient new value to write\r\n     */\r\n    @Update\r\n    suspend fun update(ingredient: IngredientDataClassDTO)\r\n\r\n    /**\r\n     * Selects and returns the row that matches the supplied start time, which is our key.\r\n     *\r\n     * @param key startTimeMilli to match\r\n     */\r\n    //Note: When returning a LiveData from a DAO function, you do not need to call suspend on said function as suspend and LiveData\r\n    //are incompatible (source:https://stackoverflow.com/questions/46445964/room-not-sure-how-to-convert-a-cursor-to-this-methods-return-type-which-meth)\r\n\r\n\r\n    /**\r\n     * Deletes all values from the table.\r\n     *\r\n     * This does not delete the table, only its contents.\r\n     */\r\n    @Query(\"DELETE FROM Ingredient_Entity\")\r\n    suspend fun clearIngredientEntity()\r\n\r\n    @Query(\"DELETE FROM RecipeEntity\")\r\n    suspend fun clearRecipeEntity()\r\n    /**\r\n     * Selects and returns all rows in the table,\r\n     *\r\n     * sorted by start time in descending order.\r\n     */\r\n    //Note: If your DAO function returns a live data then you cannot modify the DAO function with a suspend and as\r\n    //such you cannot expect the DAO function to run synchronously in testing by default.\r\n    // See: https://stackoverflow.com/questions/44270688/unit-testing-room-and-livedata for solution ; this is why\r\n    //we used the getOrAwait function in Udacity003 Project\r\n    @Query(\"SELECT * FROM Ingredient_Entity ORDER BY id DESC\")\r\n    suspend fun getAllIngredients(): List<IngredientDataClassDTO>?\r\n\r\n    /**\r\n     * Selects and returns the latest ingredient.\r\n     */\r\n    @Query(\"SELECT * FROM Ingredient_Entity ORDER BY id DESC LIMIT 1\")\r\n     suspend fun getLastIngredient(): IngredientDataClassDTO?\r\n\r\n    /**\r\n     * Selects and returns the ingredient with given nightId.\r\n     */\r\n    @Query(\"SELECT * from Ingredient_Entity WHERE id = :key\")\r\n    suspend fun getIngredientById(key: Int): IngredientDataClassDTO?\r\n\r\n/*    @Query(\"SELECT * from Ingredient_Entity WHERE id = :key\")\r\n     fun getIngredientByIdTest(key: Int): LiveData<IngredientDataClassDTO?>*/\r\n\r\n    //delete ingredient\r\n    @Query(\"DELETE from Ingredient_Entity WHERE id = :key\")\r\n     fun deleteIngredientById(key: Int)\r\n\r\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\r\n    suspend fun saveIngredient(ingredient: IngredientDataClassDTO)\r\n\r\n\r\n\r\n\r\n\r\n    @Query(\"SELECT * from RecipeEntity WHERE mId = :key\")\r\n    suspend fun getNotificationRecipeById(key: String): RecipeNotificationClassDTO?\r\n\r\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\r\n    suspend fun saveNotificationRecipe(recipeDTO: RecipeNotificationClassDTO)\r\n\r\n    @Query(\"SELECT * FROM RecipeEntity\")\r\n    suspend fun getAllRecipeNotification() : List<RecipeNotificationClassDTO>?\r\n\r\n    @Query(\"DELETE FROM RecipeEntity WHERE mId = :key\")\r\n    suspend fun deleteRecipeNotificationById(key : String)\r\n\r\n    //recipeOfDay\r\n\r\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\r\n    suspend fun saveRecipeOfDay( recipeOfDay : RecipeOfDayNetworkClassCondensed)\r\n\r\n    @Query(\"SELECT * FROM Recipe_Of_Day_Entity LIMIT 1\")\r\n    suspend fun getRecipeOfDay(): RecipeOfDayNetworkClassCondensed?\r\n\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/database/IngredientDao.kt b/app/src/main/java/com/example/nutritionapp/database/IngredientDao.kt
--- a/app/src/main/java/com/example/nutritionapp/database/IngredientDao.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/database/IngredientDao.kt	(date 1640222571854)
@@ -6,7 +6,6 @@
 import androidx.room.Insert
 import androidx.room.OnConflictStrategy
 import androidx.room.Query
-import com.example.nutritionapp.database.dto.RecipeOfDayDTO
 import com.example.nutritionapp.maps.RecipeNotificationClassDTO
 import com.example.nutritionapp.network.RecipeOfDayNetworkClassCondensed
 
Index: app/src/main/java/com/example/nutritionapp/database/IngredientDatabase.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.database\r\n\r\n/*\r\nimport androidx.room.Database\r\nimport androidx.room.RoomDatabase\r\nimport com.udacity.project4.locationreminders.data.dto.ReminderDTO\r\n\r\n/**\r\n * The Room Database that contains the reminders table.\r\n */\r\n@Database(entities = [ReminderDTO::class], version = 1, exportSchema = false)\r\nabstract class RemindersDatabase : RoomDatabase() {\r\n    abstract fun reminderDao(): RemindersDao\r\n}\r\n */\r\nimport android.content.Context\r\nimport androidx.room.Database\r\nimport androidx.room.Room\r\nimport androidx.room.RoomDatabase\r\nimport androidx.room.migration.Migration\r\nimport androidx.sqlite.db.SupportSQLiteDatabase\r\nimport com.example.nutritionapp.database.dto.IngredientDataClassDTO\r\nimport com.example.nutritionapp.database.dto.RecipeOfDayDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDTO\r\nval MIGRATION_4_5: Migration = object : Migration(4, 5) {\r\n    override fun migrate(database: SupportSQLiteDatabase) {\r\n        database.beginTransaction()\r\n        // https://developer.android.com/reference/android/arch/persistence/room/ColumnInfo\r\n        database.execSQL(\"CREATE TABLE IF NOT EXISTS `RecipeOfDayDTO` (`id` TEXT, `vegetarian` \" +\r\n                \"INTEGER, `vegan` INTEGER, `glutenFree` INTEGER, `dairyFree` INTEGER,\" +\r\n                \"`veryHealthy` INTEGER, `image` TEXT, `imageType` TEXT, `instructions` TEXT)\")\r\n        database.setTransactionSuccessful()\r\n        database.endTransaction()\r\n    }\r\n}\r\n\r\n@Database(entities = [IngredientDataClassDTO::class, RecipeNotificationClassDTO::class, RecipeOfDayDTO::class], version = 8, exportSchema = false)\r\nabstract class IngredientDatabase : RoomDatabase() {\r\n\r\n    /**\r\n     * Connects the database to the DAO.\r\n     */\r\n    abstract val IngredientDatabaseDao: IngredientDao\r\n    /**\r\n     * Define a companion object, this allows us to add functions on the IngredientDatabase class.\r\n     *\r\n     * For example, clients can call `IngredientDatabase.getInstance(context)` to instantiate\r\n     * a new IngredientDatabase.\r\n     */\r\n    companion object {\r\n        /**\r\n         * INSTANCE will keep a reference to any database returned via getInstance.\r\n         *\r\n         * This will help us avoid repeatedly initializing the database, which is expensive.\r\n         *\r\n         *  The value of a volatile variable will never be cached, and all writes and\r\n         *  reads will be done to and from the main memory. It means that changes made by one\r\n         *  thread to shared data are visible to other threads.\r\n         */\r\n        @Volatile\r\n        private var INSTANCE: IngredientDatabase? = null\r\n\r\n        /**\r\n         * Helper function to get the database.\r\n         *\r\n         * If a database has already been retrieved, the previous database will be returned.\r\n         * Otherwise, create a new database.\r\n         *\r\n         * This function is threadsafe, and callers should cache the result for multiple database\r\n         * calls to avoid overhead.\r\n         *\r\n         * This is an example of a simple Singleton pattern that takes another Singleton as an\r\n         * argument in Kotlin.\r\n         *\r\n         * To learn more about Singleton read the wikipedia article:\r\n         * https://en.wikipedia.org/wiki/Singleton_pattern\r\n         *\r\n         * @param context The application context Singleton, used to get access to the filesystem.\r\n         */\r\n        fun getInstance(context: Context): IngredientDatabase {\r\n            // Multiple threads can ask for the database at the same time, ensure we only initialize\r\n            // it once by using synchronized. Only one thread may enter a synchronized block at a\r\n            // time.\r\n            synchronized(this) {\r\n                // Copy the current value of INSTANCE to a local variable so Kotlin can smart cast.\r\n                // Smart cast is only available to local variables.\r\n                var instance = INSTANCE\r\n                // If instance is `null` make a new database instance.\r\n                if (instance == null) {\r\n                    instance = Room.databaseBuilder(\r\n                        context.applicationContext,\r\n                        IngredientDatabase::class.java,\r\n                        \"saved_ingredient_database\"\r\n                    )\r\n                        // Wipes and rebuilds instead of migrating if no Migration object.\r\n                        // Migration is not part of this lesson. You can learn more about\r\n                        // migration with Room in this blog post:\r\n                        // https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929\r\n                        .fallbackToDestructiveMigration().build()//addMigrations(MIGRATION_4_5)\r\n                    // Assign INSTANCE to the newly created database.\r\n                    INSTANCE = instance\r\n                }\r\n                // Return instance; smart cast to be non-null.\r\n                return instance\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/database/IngredientDatabase.kt b/app/src/main/java/com/example/nutritionapp/database/IngredientDatabase.kt
--- a/app/src/main/java/com/example/nutritionapp/database/IngredientDatabase.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/database/IngredientDatabase.kt	(date 1640222571874)
@@ -20,7 +20,7 @@
 import androidx.room.migration.Migration
 import androidx.sqlite.db.SupportSQLiteDatabase
 import com.example.nutritionapp.database.dto.IngredientDataClassDTO
-import com.example.nutritionapp.database.dto.RecipeOfDayDTO
+import com.example.nutritionapp.database.dto.RecipeOfDayDTOTest
 import com.example.nutritionapp.maps.RecipeNotificationClassDTO
 val MIGRATION_4_5: Migration = object : Migration(4, 5) {
     override fun migrate(database: SupportSQLiteDatabase) {
@@ -34,7 +34,7 @@
     }
 }
 
-@Database(entities = [IngredientDataClassDTO::class, RecipeNotificationClassDTO::class, RecipeOfDayDTO::class], version = 8, exportSchema = false)
+@Database(entities = [IngredientDataClassDTO::class, RecipeNotificationClassDTO::class, RecipeOfDayDTOTest::class], version = 8, exportSchema = false)
 abstract class IngredientDatabase : RoomDatabase() {
 
     /**
Index: app/src/main/java/com/example/nutritionapp/database/IngredientDataSourceInterface.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.database\r\nimport com.example.nutritionapp.util.Result\r\nimport com.example.nutritionapp.database.dto.IngredientDataClassDTO\r\nimport com.example.nutritionapp.database.dto.RecipeOfDayDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDomain\r\nimport com.example.nutritionapp.network.RecipeOfDayNetworkClassCondensed\r\n\r\ninterface IngredientDataSourceInterface {\r\n\r\n    //\"Result\" encapsulates successful outcome with a value of type [T] or a failure with message and statusCode\r\n    suspend fun getIngredients(): Result<List<IngredientDataClassDTO>>\r\n    suspend fun saveNewIngredient(ingredient: IngredientDataClass)\r\n    suspend fun update(ingredient : IngredientDataClass)\r\n    suspend fun getIngredient(id: Int): Result<IngredientDataClassDTO>\r\n    suspend fun deleteAllIngredients()\r\n    suspend fun deleteTaskIngredient(id: Int)\r\n\r\n    suspend fun saveRecipeOfDay(recipeOfDay : RecipeOfDayNetworkClassCondensed)\r\n    suspend fun getRecipeOfDay() : Result<RecipeOfDayNetworkClassCondensed>\r\n\r\n    suspend fun getNotificationRecipeById (key: String) : Result<RecipeNotificationClassDomain>?\r\n    suspend fun saveNotificationRecipe (recipeDomain : RecipeNotificationClassDomain)\r\n    suspend fun clearNotificationRecipe()\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/database/IngredientDataSourceInterface.kt b/app/src/main/java/com/example/nutritionapp/database/IngredientDataSourceInterface.kt
--- a/app/src/main/java/com/example/nutritionapp/database/IngredientDataSourceInterface.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/database/IngredientDataSourceInterface.kt	(date 1640222571885)
@@ -1,8 +1,6 @@
 package com.example.nutritionapp.database
 import com.example.nutritionapp.util.Result
 import com.example.nutritionapp.database.dto.IngredientDataClassDTO
-import com.example.nutritionapp.database.dto.RecipeOfDayDTO
-import com.example.nutritionapp.maps.RecipeNotificationClassDTO
 import com.example.nutritionapp.maps.RecipeNotificationClassDomain
 import com.example.nutritionapp.network.RecipeOfDayNetworkClassCondensed
 
Index: app/src/main/java/com/example/nutritionapp/database/IngredientRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.database\r\n\r\nimport android.util.Log\r\nimport com.example.nutritionapp.util.Result\r\nimport com.example.nutritionapp.database.dto.IngredientDataClassDTO\r\nimport com.example.nutritionapp.database.dto.RecipeOfDayDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDomain\r\nimport com.example.nutritionapp.network.RecipeOfDayNetworkClassCondensed\r\nimport com.example.nutritionapp.util.wrapEspressoIdlingResource\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.withContext\r\n\r\nclass IngredientRepository(private val dao: IngredientDao,\r\n                           private val IOdispatcher: CoroutineDispatcher = Dispatchers.IO) : IngredientDataSourceInterface {\r\n    //will get ingredient searches directly from network and not the repository\r\n\r\n    override suspend fun getIngredients(): Result<List<IngredientDataClassDTO>> {\r\n        Log.i(\"test\",\"getIngredients real repo called\")\r\n        wrapEspressoIdlingResource {\r\n        //make the function main-safe by switching thread to IO thread; also we maintain structured concurrency by not declaring a new\r\n        //coroutine scope\r\n        var resultGetIngredients: List<IngredientDataClassDTO>? = null\r\n\r\n        return withContext(IOdispatcher)\r\n        {\r\n            resultGetIngredients = dao.getAllIngredients()\r\n\r\n            if (!resultGetIngredients.isNullOrEmpty()) {\r\n                //https://stackoverflow.com/questions/46040027/how-to-convert-livedatalistfoo-into-livedatalistbar\r\n            //resultGetIngredients = Result.Success(convertedIngredients)\r\n            return@withContext Result.Success(resultGetIngredients!!)\r\n            } else {\r\n                return@withContext Result.Error(\"No ingredients found\")\r\n            }\r\n        }\r\n    }\r\n    }\r\n\r\n    override suspend fun saveNewIngredient(ingredient: IngredientDataClass) {\r\n        wrapEspressoIdlingResource {\r\n            dao.saveIngredient(\r\n                IngredientDataClassDTO(\r\n                    name = ingredient.name,\r\n                    quantity = ingredient.quantity,\r\n                    id = ingredient.id,\r\n                    image = ingredient.imageUrl,\r\n                    imageType = ingredient.imageType\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    override suspend fun update(ingredient: IngredientDataClass) {\r\n        wrapEspressoIdlingResource {\r\n            dao.update(\r\n                IngredientDataClassDTO(\r\n                    name = ingredient.name,\r\n                    quantity = ingredient.quantity,\r\n                    id = ingredient.id,\r\n                    image = ingredient.imageUrl,\r\n                    imageType = ingredient.imageType\r\n                )\r\n            )\r\n        }\r\n    }\r\n        //Note: we perform the transformation in the viewModel, that way we can mark the DAO functions as suspend\r\n    override suspend fun getIngredient(id: Int): Result<IngredientDataClassDTO> {\r\n            wrapEspressoIdlingResource {\r\n                return withContext(IOdispatcher)\r\n                {\r\n                    //return Result.Success(database.IngredientDatabaseDao.getIngredientById(id))\r\n                    val resultGetIngredients = dao.getIngredientById(id)\r\n                    if (resultGetIngredients == null) {\r\n                        return@withContext Result.Error(\"Could not find ingredient\")\r\n                    } else {\r\n                        return@withContext Result.Success(resultGetIngredients)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    override suspend fun deleteAllIngredients() {\r\n        wrapEspressoIdlingResource {\r\n            withContext(IOdispatcher)\r\n            {\r\n                dao.clearIngredientEntity()\r\n                dao.clearRecipeEntity()\r\n            }\r\n        }\r\n    }\r\n\r\n    override suspend fun clearNotificationRecipe() {\r\n        wrapEspressoIdlingResource {\r\n            withContext(IOdispatcher)\r\n            {\r\n                dao.clearRecipeEntity()\r\n            }\r\n        }\r\n    }\r\n\r\n    override suspend fun deleteTaskIngredient(id: Int) {\r\n        wrapEspressoIdlingResource {\r\n            withContext(IOdispatcher)\r\n            {\r\n                dao.deleteIngredientById(id)\r\n            }\r\n        }\r\n    }\r\n\r\n    override suspend fun saveRecipeOfDay(recipeOfDay: RecipeOfDayNetworkClassCondensed) {\r\n    wrapEspressoIdlingResource {\r\n    return withContext(IOdispatcher)\r\n    {\r\n        dao.saveRecipeOfDay(recipeOfDay)\r\n    }\r\n        }\r\n    }\r\n\r\n    override suspend fun getRecipeOfDay(): Result<RecipeOfDayNetworkClassCondensed> {\r\n        wrapEspressoIdlingResource {\r\n            return withContext(IOdispatcher)\r\n            {\r\n               val result : RecipeOfDayNetworkClassCondensed? = dao.getRecipeOfDay()\r\n                if (result?.image.isNullOrEmpty() != true)\r\n                {\r\n                    return@withContext Result.Success(result!!)\r\n                }\r\n                else\r\n                    return@withContext Result.Error(\"Missing Recipe of Day\")\r\n            }\r\n        }\r\n    }\r\n\r\n    override suspend fun getNotificationRecipeById(key: String): Result<RecipeNotificationClassDomain>? {\r\n        wrapEspressoIdlingResource {\r\n            return withContext(IOdispatcher)\r\n            {\r\n                val result = dao.getNotificationRecipeById(key)\r\n                if (result != null) {\r\n                    return@withContext Result.Success(RecipeNotificationClassDomain(\r\n                        recipeName = result.recipeName,\r\n                        missingIngredients = result.missingIngredients,\r\n                        mId = result.mId\r\n                    ))\r\n                }\r\n                else\r\n                    return@withContext Result.Error(null)\r\n            }\r\n        }\r\n    }\r\n\r\n    override suspend fun saveNotificationRecipe(recipeDomain: RecipeNotificationClassDomain) {\r\nwrapEspressoIdlingResource {\r\n    withContext(IOdispatcher)\r\n    {\r\n        dao.saveNotificationRecipe(RecipeNotificationClassDTO(recipeName = recipeDomain.recipeName, missingIngredients = recipeDomain.missingIngredients,\r\n        mId = recipeDomain.mId) )\r\n    } }}\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/database/IngredientRepository.kt b/app/src/main/java/com/example/nutritionapp/database/IngredientRepository.kt
--- a/app/src/main/java/com/example/nutritionapp/database/IngredientRepository.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/database/IngredientRepository.kt	(date 1640222571936)
@@ -3,7 +3,6 @@
 import android.util.Log
 import com.example.nutritionapp.util.Result
 import com.example.nutritionapp.database.dto.IngredientDataClassDTO
-import com.example.nutritionapp.database.dto.RecipeOfDayDTO
 import com.example.nutritionapp.maps.RecipeNotificationClassDTO
 import com.example.nutritionapp.maps.RecipeNotificationClassDomain
 import com.example.nutritionapp.network.RecipeOfDayNetworkClassCondensed
Index: app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.ingredientlist\r\n\r\n//import androidx.test.core.app.ApplicationProvider\r\n\r\nimport android.app.Application\r\nimport android.content.Context\r\nimport android.net.ConnectivityManager\r\nimport android.net.NetworkCapabilities\r\nimport android.os.Build\r\nimport android.util.Log\r\nimport android.widget.Toast\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.databinding.Observable\r\nimport androidx.databinding.PropertyChangeRegistry\r\nimport androidx.lifecycle.*\r\nimport androidx.test.core.app.ApplicationProvider\r\nimport com.example.nutritionapp.database.IngredientDataClass\r\nimport com.example.nutritionapp.database.IngredientDataSourceInterface\r\nimport com.example.nutritionapp.database.dto.IngredientDataClassDTO\r\nimport com.example.nutritionapp.database.dto.RecipeOfDayDTO\r\nimport com.example.nutritionapp.maps.RecipeNotificationClassDomain\r\nimport com.example.nutritionapp.network.*\r\nimport com.example.nutritionapp.recipe.*\r\nimport com.example.nutritionapp.util.Result\r\nimport com.example.nutritionapp.util.succeeded\r\nimport com.example.nutritionapp.util.wrapEspressoIdlingResource\r\nimport com.google.android.gms.maps.model.LatLng\r\nimport com.squareup.moshi.Moshi\r\nimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory\r\nimport kotlinx.coroutines.*\r\nimport org.jetbrains.annotations.TestOnly\r\nimport timber.log.Timber\r\nimport java.net.URLEncoder\r\n\r\n\r\n/*\r\nTo get context inside a ViewModel we can either extend AndroidViewModel. Do not use ApplicationProvider in production code, only in tests\r\nhttps://stackoverflow.com/questions/51451819/how-to-get-context-in-android-mvvm-viewmodel\r\n */\r\n\r\nval selectedProductName = MutableLiveData<String>(\"Apple,flour,sugar\")\r\n\r\nclass IngredientViewModel(\r\n    val app: Application,\r\n    val ingredientRepository: IngredientDataSourceInterface, val nutritionApi: mNutritionApi\r\n) : AndroidViewModel(app) {\r\n\r\n//--------------------------------------------------------IngredientListOverview Fragment-----------------------------------------------\r\n    //Note: Don't set the MutableLiveData to null, b/c technically it is not initialized so any assignment will not change the null value\r\n    //and variable observing this MutableLiveData will return null\r\n\r\n    //flag for shopping cart image\r\n    private val _shoppingCartVisibilityFlag = MutableLiveData(true)\r\n    val shoppingCartVisibilityFlag: LiveData<Boolean>\r\n        get() = _shoppingCartVisibilityFlag\r\n\r\n    //flag for navigating once coroutine involving search recipe button in ingredientListFragment is finished\r\n    private val _navigatorFlag = MutableLiveData<Boolean>(false)\r\n    val navigatorFlag: LiveData<Boolean>\r\n        get() = _navigatorFlag\r\n\r\n    fun setNavigatorFlag(boolean: Boolean) {\r\n        _navigatorFlag.value = boolean\r\n    }\r\n\r\n    private val _viewVisibilityFlag = MutableLiveData<Boolean>(false)\r\n    val viewVisibilityFlag: LiveData<Boolean>\r\n        get() = _viewVisibilityFlag\r\n\r\n    private val _mutableLiveDataList: MutableLiveData<List<IngredientDataClass>> = MutableLiveData()\r\n\r\n    val mutableLiveDataList: LiveData<List<IngredientDataClass>>\r\n        get() = _mutableLiveDataList\r\n    @TestOnly\r\n    fun changedMutableLiveData( mList: List<IngredientDataClass>)\r\n    {\r\n        _mutableLiveDataList.postValue(mList)\r\n    }\r\n\r\n    private val _listOfSavedIngredients: MutableLiveData<List<IngredientDataClass>> =\r\n        MutableLiveData()\r\n    val listOfSavedIngredients: LiveData<List<IngredientDataClass>>\r\n        get() = _listOfSavedIngredients\r\n\r\n    //two-way binding\r\n    //no need to add \"?query=\" since the getIngredients() of the IngredientsApiInterface will do that\r\n    var searchItem = MutableLiveData<String>()\r\n\r\n    val foodInText = mutableListOf<String>()\r\n\r\n    private val _navigateToDetail = MutableLiveData<IngredientDataClass>()\r\n    val navigateToDetail: LiveData<IngredientDataClass>\r\n        get() = _navigateToDetail\r\n\r\n    fun setNavigateToDetail(ingredientItem: IngredientDataClass) {\r\n        selectedIngredient.value = ingredientItem\r\n        _quantityCounter.value = ingredientItem.quantity\r\n        _navigateToDetail.value = ingredientItem\r\n    }\r\n\r\n    fun setNavigateToDetailNull() {\r\n        _navigateToDetail.value = null\r\n    }\r\n\r\n    //--------------------------------------------------------mapGroceryReminder--------------------------------------------------------\r\n\r\n    private val _latLng = MutableLiveData<LatLng>()\r\n    val latLng: LiveData<LatLng>\r\n        get() = _latLng\r\n\r\n    fun setLatLng(latLng: LatLng) {\r\n        _latLng.value = latLng\r\n    }\r\n\r\n    private val _saveRecipeNotificationFlag = MutableLiveData(false)\r\n\r\n\r\n    //--------------------------------------------------------ingredientDetail Fragment ---------------------------------------------------\r\n    val selectedIngredient = MutableLiveData<IngredientDataClass>()\r\n\r\n    private val _quantityCounter = MutableLiveData<Int>(1)\r\n    val quantityCounter: LiveData<Int>\r\n        get() = _quantityCounter\r\n\r\n    fun increaseQuantityCounter() {\r\n        val temp = _quantityCounter.value?.plus(1)\r\n        _quantityCounter.value = temp\r\n        selectedIngredient.value?.quantity = temp!!\r\n    }\r\n\r\n    fun decreaseQuantityCounter() {\r\n        if (_quantityCounter.value!! > 0) {\r\n            //note - we need to reassign the mutableLiveData to a new variable for observers to observe a change in value\r\n            //you can't just update the existing value inside the mutableLiveData\r\n            val temp = _quantityCounter.value!!.minus(1)\r\n            _quantityCounter.value = temp\r\n            selectedIngredient.value?.quantity = temp\r\n        }\r\n    }\r\n\r\n    //--------------------------------------------------------recipeDetail Fragment ---------------------------------------------------\r\n    private val _missingIngredients = MutableLiveData<List<String>>()\r\n    val missingIngredients: LiveData<List<String>>\r\n        get() = _missingIngredients\r\n\r\n    private val _listOfStepsLiveData = MutableLiveData<List<String>>()\r\n    val listOfStepsLiveData: LiveData<List<String>>\r\n        get() = _listOfStepsLiveData\r\n\r\n    fun setMissingIngredientsNull() {\r\n        _missingIngredients.value = null\r\n    }\r\n\r\n    //--------------------------------------------------------SearchRecipe Fragment--------------------------------------------------------\r\n    //Q: Why does \"val listOfRecipesLiveData = MutableLiveData<List<RecipeIngredientResult>>(listOfRecipes)\" result in RecyclerView\r\n    //being empty?\r\n    //A: \"val listOfRecipesLiveData : MutableLiveData<List<RecipeIngredientResult>>? = null\" is explicitly setting the list<RecipeIngredientResult> value\r\n    //to null so that even if we add new values to the list<RecipeIngredientResult> the observers are not notified since MutableLiveData is still observing\r\n    //the same list. As such, you need to set a new list instead of updating the existing list since the list reference does not technically change when you\r\n    //add new values to the list so the observers are not notified. (?) \"MutableLiveData<List<RecipeIngredientResult>>()\" is correct because initially there\r\n    //is not value explicitly assigned to list<RecipeIngredientResult> so the first time a list is assigned the observers are signaled.\r\n    //A work around is offered at source: https://stackoverflow.com/questions/61834480/livedata-is-not-triggered-when-list-item-is-getting-updated\r\n\r\n\r\n    val _listOfRecipesLiveData = MutableLiveData<List<RecipeIngredientResult>>()\r\n    val listOfRecipesLiveData: LiveData<List<RecipeIngredientResult>>\r\n        get() = _listOfRecipesLiveData\r\n\r\n    val searchRecipeEditTextFlag = MutableLiveData(false)\r\n\r\n    fun setSearchRecipeEditTextClear() {\r\n        foodInText.clear()\r\n    }\r\n    //Two-way data binding\r\n    val listOfIngredientsString = MutableLiveData<String>()\r\n\r\n    private var _navigateToRecipeFlag = MutableLiveData(false)\r\n    val navigateToRecipeFlag: LiveData<Boolean>\r\n        get() = _navigateToRecipeFlag\r\n\r\n\r\n    private val _navigateToRecipe = MutableLiveData<RecipeIngredientResult>()\r\n    val navigateToRecipe: LiveData<RecipeIngredientResult>\r\n        get() = _navigateToRecipe\r\n\r\n    fun setNavigateToRecipe(recipe: RecipeIngredientResult) {\r\n        _navigateToRecipe.value = recipe\r\n    }\r\n\r\n    fun setNavigateToRecipeNull() {\r\n        _navigateToRecipe.value = null\r\n    }\r\n\r\n    fun setNavigateToRecipeFlag(boolean: Boolean) {\r\n        _navigateToRecipeFlag.value = boolean\r\n    }\r\n\r\n    private val _recipeOfDay = MutableLiveData<String>()\r\n    val recipeOfDay : LiveData<String>\r\n    get() = _recipeOfDay\r\n\r\n    fun getRecipeOfDayDatabase(){\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                val recipeOfDayResult = ingredientRepository.getRecipeOfDay()\r\n                when(recipeOfDayResult)\r\n                {\r\n                    is Result.Success<RecipeOfDayNetworkClassCondensed> ->{\r\n                        _recipeOfDay.value = recipeOfDayResult.data.image\r\n                    Timber.i(_recipeOfDay.value)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun getRecipeOfDayNetworkRequest()\r\n    {\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n               val result = ServiceLocator.mNutritionObject.nutritionService.getRecipeOfDay()\r\n\r\n                _recipeOfDay.value = result.image\r\n                Log.i(\"log\",\"result: ${result?.image}\")\r\n            }\r\n        }\r\n    }\r\n\r\n    //input is list of names i.e {\"Snapple Apple flavored drink 4oz\",\"Mott's Apple pudding 3oz\"}\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun detectFoodInText(listName: List<String>) {\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                _viewVisibilityFlag.value = true\r\n                try {\r\n                    for (i in listName) {\r\n                        //Note: For a post request, you can either provide a request body, passing in your text to the request body or you\r\n                        //can provide a text parameter within the suspend function in your API Interface.\r\n                        selectedProductName.value = URLEncoder.encode(i, \"utf-8\").toString()\r\n                        nutritionApi.setBody()\r\n                        Log.i(\"testURLEncoded: \", selectedProductName.value.toString())\r\n                        val listOfIngredients: PostRequestResultWrapper =\r\n                            nutritionApi.nutritionServicePost.detectFoodInText(\r\n                            )\r\n                        for (g in listOfIngredients.annotations) {\r\n                            Log.i(\"testURLAnnotation\", g.annotation)\r\n                            foodInText.add(g.annotation)\r\n                        }\r\n                    }\r\n                } catch (e: java.lang.Exception) {\r\n                    if (!isOnline(app)) {\r\n                        displayToast(\"Not connected to internet\")\r\n                    }\r\n                    Log.i(\"Exception\", \"$e\")\r\n                }\r\n\r\n                if (!foodInText.isEmpty()) {\r\n                    listOfIngredientsString.value = foodInText.joinToString(separator = \",\")\r\n                    _navigatorFlag.value = true\r\n                }\r\n                _viewVisibilityFlag.value = false\r\n            }\r\n        }\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun findRecipeByIngredients() {\r\n        val listOfRecipes = mutableListOf<RecipeIngredientResult>()\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                _viewVisibilityFlag.value = true\r\n                try {\r\n                    val resultWrapper: List<RecipeIngredientResult> =\r\n                        nutritionApi.nutritionService.findByIngredients(\r\n                            listOfIngredientsString.value!!\r\n                        )\r\n                    Log.i(\"testRecipeById\", \"recipe list size: ${resultWrapper.size}\")\r\n                    Log.i(\"testRecipeById\", \"recipe[0]: ${resultWrapper[0].title}\")\r\n                    for (i in resultWrapper) {\r\n                        listOfRecipes.add(i)\r\n                    }\r\n\r\n                    _listOfRecipesLiveData.value = listOfRecipes\r\n\r\n                } catch (e: java.lang.Exception) {\r\n                    if (!isOnline(app)) {\r\n                        displayToast(\"Not connected to internet\")\r\n                    }\r\n\r\n                    Log.i(\"Exception\", \"$e\")\r\n                }\r\n                _viewVisibilityFlag.value = false\r\n            }\r\n        }\r\n    }\r\n\r\n    //source: https://stackoverflow.com/questions/51141970/check-internet-connectivity-android-in-kotlin\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun isOnline(context: Context): Boolean {\r\n        val connectivityManager =\r\n            context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\r\n\r\n        val capabilities =\r\n            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {\r\n                Log.i(\"test\", \">M\")\r\n                connectivityManager.getNetworkCapabilities(connectivityManager.activeNetwork)\r\n            } else {\r\n                TODO(\"VERSION.SDK_INT < M\")\r\n            }\r\n        if (capabilities != null) {\r\n            if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {\r\n                Log.i(\"Internet\", \"NetworkCapabilities.TRANSPORT_CELLULAR\")\r\n                return true\r\n            } else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {\r\n                Log.i(\"Internet\", \"NetworkCapabilities.TRANSPORT_WIFI\")\r\n                return true\r\n            } else if (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) {\r\n                Log.i(\"Internet\", \"NetworkCapabilities.TRANSPORT_ETHERNET\")\r\n                return true\r\n            }\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n\r\n    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)\r\n    fun loadIngredientListByNetwork() {\r\n        wrapEspressoIdlingResource {\r\n            Log.i(\"viewModel\",\"load called\")\r\n            var listOfNetworkRequestedIngredients: List<IngredientDataClass>? = null\r\n            viewModelScope.launch {\r\n                _viewVisibilityFlag.postValue(true)\r\n                if (searchItem.value != null) {\r\n                    try {\r\n                        val result: wrapperIngredientListNetworkDataClass =\r\n                            nutritionApi.nutritionService.getIngredients(searchItem.value!!)\r\n                        Log.i(\"test\", \"search item: ${searchItem.value}\")\r\n                        Log.i(\"test1\", \"Total products: ${result}\")\r\n\r\n                        listOfNetworkRequestedIngredients = result.toDomainType()\r\n                        Log.i(\"viewModel\", listOfNetworkRequestedIngredients!![0].name)\r\n                        _mutableLiveDataList.value = (listOfNetworkRequestedIngredients)\r\n                        Log.i(\"viewModelMutable\", _mutableLiveDataList.value!![0].name)\r\n\r\n                        Toast.makeText(\r\n                            app,\r\n                            \"networkRequestSuccess\",\r\n                            Toast.LENGTH_SHORT\r\n                        ).show()\r\n\r\n                        val tempBool = false\r\n                        _shoppingCartVisibilityFlag.postValue(tempBool)\r\n\r\n                    } catch (e: Exception) {\r\n\r\n                        if (!isOnline(app)) {\r\n                            displayToast(\"Not connected to internet\")\r\n                        }\r\n                        println(\"Error: ${e.message}\")\r\n                    }\r\n                }\r\n                _viewVisibilityFlag.postValue(false)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun displayToast(mString: String) {\r\n        Toast.makeText(\r\n            app,\r\n            mString,\r\n            Toast.LENGTH_SHORT\r\n        ).show()\r\n    }\r\n\r\n    fun saveRecipeNotification(recipeNotificationClassDomain: RecipeNotificationClassDomain) {\r\n\r\n        viewModelScope.launch {\r\n            ingredientRepository.saveNotificationRecipe(\r\n                RecipeNotificationClassDomain(\r\n                    recipeName = recipeNotificationClassDomain.recipeName,\r\n                    missingIngredients = recipeNotificationClassDomain.missingIngredients,\r\n                    mId = recipeNotificationClassDomain.mId\r\n                )\r\n            )\r\n            _saveRecipeNotificationFlag.value = true\r\n        }\r\n    }\r\n\r\n    val mFlag = MutableLiveData(false)\r\n    fun getRecipeInstructions() {\r\n        val listOfIngredientNameInInstruction = mutableListOf<String>()\r\n\r\n        val listOfSteps = mutableListOf<String>()\r\n\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n\r\n                //Note: So the issue here was that the coroutine has not finished running. The solution was to make the network request function a\r\n                // regular function to make it blocking Since the network function was initially a suspend function, the rest of the code was\r\n                // proceeding under the assumption that \"resultInstructions\" was null. Even if \"resultInstructions\" returns a value the rest\r\n                // of the code logic had already ran. So the solution was to make \"resultInstructions\" blocking.\r\n\r\n                //Coroutines execute synchronously so the CoroutineScope of the Main thread will ensure that the job in Dispatchers.IO is\r\n                //finished first before proceeding.\r\n                //avoids NetworkOnMainThread exception error by running on a non-Main thread\r\n                //Q: Why is this working but not the previous network request format?\r\n                val networkResult: List<RecipeInstruction>? =\r\n                    _navigateToRecipe.value?.id?.let {\r\n                        nutritionApi.nutritionService.getRecipeInstructions(it, false)\r\n                    }\r\n\r\n                //iterates over each sub recipe i.e recipe for cake and recipe for frosting\r\n                if (!networkResult.isNullOrEmpty()) {\r\n\r\n                    for (i in networkResult) {\r\n                        //adds title of sub recipes i.e frosting recipe in a cake recipe\r\n                        if (i.name?.length!! > 0)\r\n                            listOfSteps.add(i.name)\r\n\r\n                        //iterates over \"RecipeInstruction\" to add the instructions steps into a list\r\n                        for (steps in i.steps!!) {\r\n                            //collects the ingredients mentioned in the recipe instructions\r\n                            for (name in steps.ingredients!!) {\r\n                                if (!name.name.isNullOrEmpty()) {\r\n                                    listOfIngredientNameInInstruction.add(name.name)\r\n                                }\r\n                            }\r\n                            steps.step?.let { listOfSteps.add(it) }\r\n                        }\r\n                    }\r\n\r\n                    _listOfStepsLiveData.value = listOfSteps\r\n                    val removeDuplicates = listOfIngredientNameInInstruction.toSet().toList()\r\n                    _missingIngredients.value = removeDuplicates.minus(\r\n                        foodInText\r\n                    )\r\n                    mFlag.value = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun saveIngredientItem() {\r\n        if (selectedIngredient.value != null && selectedIngredient.value?.quantity!! >= 0) {\r\n            wrapEspressoIdlingResource {\r\n                viewModelScope.launch {\r\n                    selectedIngredient.value?.let { ingredientRepository.saveNewIngredient(it) }\r\n                }\r\n            }\r\n        } else\r\n            Toast.makeText(app, \"Invalid quantity\", Toast.LENGTH_SHORT).show()\r\n    }\r\n\r\n    fun getLocalIngredientList() { //need DAO and repository\r\n        Log.i(\"test\", \"getLocalList called\")\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n\r\n                val ingredientResult: Result<List<IngredientDataClassDTO>> =\r\n                    ingredientRepository.getIngredients()\r\n                when (ingredientResult) {\r\n                    is Result.Success<*> -> {\r\n                        val dataList = ArrayList<IngredientDataClass>()\r\n                        dataList.addAll((ingredientResult.data as List<IngredientDataClassDTO>).map { result ->\r\n                            //map the reminder data from the DB to the be ready to be displayed on the UI\r\n                            IngredientDataClass(\r\n                                id = result.id,\r\n                                name = result.name,\r\n                                quantity = result.quantity,\r\n                                imageUrl = result.image,\r\n                                imageType = result.imageType\r\n                            )\r\n                        })\r\n                        _listOfSavedIngredients.postValue(dataList)\r\n                    }\r\n                    is Result.Error -> {\r\n                        Log.i(\"test\", \"empty repository\")\r\n//                Toast.makeText(ApplicationProvider.getApplicationContext(),\"${ingredientResult.message}\",Toast.LENGTH_SHORT).show()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun clearRecipeNotificationTable() {\r\n        wrapEspressoIdlingResource {\r\n            viewModelScope.launch {\r\n                ingredientRepository.clearNotificationRecipe()\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    override fun onCleared() {\r\n        super.onCleared()\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt b/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt
--- a/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/ingredientlist/IngredientViewModel.kt	(date 1640222571827)
@@ -10,23 +10,16 @@
 import android.util.Log
 import android.widget.Toast
 import androidx.annotation.RequiresApi
-import androidx.databinding.Observable
-import androidx.databinding.PropertyChangeRegistry
 import androidx.lifecycle.*
-import androidx.test.core.app.ApplicationProvider
 import com.example.nutritionapp.database.IngredientDataClass
 import com.example.nutritionapp.database.IngredientDataSourceInterface
 import com.example.nutritionapp.database.dto.IngredientDataClassDTO
-import com.example.nutritionapp.database.dto.RecipeOfDayDTO
 import com.example.nutritionapp.maps.RecipeNotificationClassDomain
 import com.example.nutritionapp.network.*
 import com.example.nutritionapp.recipe.*
 import com.example.nutritionapp.util.Result
-import com.example.nutritionapp.util.succeeded
 import com.example.nutritionapp.util.wrapEspressoIdlingResource
 import com.google.android.gms.maps.model.LatLng
-import com.squareup.moshi.Moshi
-import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
 import kotlinx.coroutines.*
 import org.jetbrains.annotations.TestOnly
 import timber.log.Timber
Index: app/src/main/java/com/example/nutritionapp/network/RecipeOfDayWorker.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.nutritionapp.network\r\n\r\nimport android.content.Context\r\nimport android.util.Log\r\nimport androidx.work.CoroutineWorker\r\nimport androidx.work.WorkerParameters\r\nimport com.example.nutritionapp.database.dto.RecipeOfDayDTO\r\nimport retrofit2.HttpException\r\nimport timber.log.Timber\r\n\r\n\r\nclass RecipeOfDayWorker (appContext: Context, params: WorkerParameters):\r\n    CoroutineWorker(appContext, params) {\r\n        companion object {\r\n            const val WORK_NAME = \"RecipeOfDayWorker\"\r\n        }\r\n\r\n        override suspend fun doWork(): Result {\r\n            val repository = ServiceLocator.ingredientRepository\r\n            val nutritionObject = ServiceLocator.mNutritionObject\r\n\r\n            return try {\r\n                Timber.i(\"Work triggered\")\r\n                Log.i(\"log\",\"work triggered\")\r\n                val recipeOfDayResult = nutritionObject.nutritionService.getRecipeOfDay()\r\n                val recipeOfDayNetworkClassCondensed = recipeOfDayResult.id?.let {\r\n                    recipeOfDayResult.image?.let { it1 ->\r\n                        RecipeOfDayNetworkClassCondensed(id = it,\r\n                            image = it1\r\n                        )\r\n                    }\r\n                }\r\n\r\n                if (!recipeOfDayNetworkClassCondensed?.image.isNullOrEmpty() && recipeOfDayNetworkClassCondensed != null)\r\n                {\r\n                    repository?.saveRecipeOfDay(recipeOfDayNetworkClassCondensed)\r\n                }\r\n                Result.success()\r\n            } catch (e: HttpException) {\r\n                Result.retry()\r\n            }\r\n        }\r\n    }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/network/RecipeOfDayWorker.kt b/app/src/main/java/com/example/nutritionapp/network/RecipeOfDayWorker.kt
--- a/app/src/main/java/com/example/nutritionapp/network/RecipeOfDayWorker.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/network/RecipeOfDayWorker.kt	(date 1640222571865)
@@ -4,7 +4,6 @@
 import android.util.Log
 import androidx.work.CoroutineWorker
 import androidx.work.WorkerParameters
-import com.example.nutritionapp.database.dto.RecipeOfDayDTO
 import retrofit2.HttpException
 import timber.log.Timber
 
Index: app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTO.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTO.kt b/app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTOTest.kt
rename from app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTO.kt
rename to app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTOTest.kt
--- a/app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTO.kt	(revision eab89f0f8931edc0cef86cae608522e2ad30c63a)
+++ b/app/src/main/java/com/example/nutritionapp/database/dto/RecipeOfDayDTOTest.kt	(date 1640222571927)
@@ -8,7 +8,7 @@
 import java.util.*
 
 @Entity(tableName = "Recipe_Of_Day_Entity")
-data class RecipeOfDayDTO(
+data class RecipeOfDayDTOTest(
     @PrimaryKey(autoGenerate = false)
     val id : Int,
     val image : String?
